const fs = require("fs").promises;
const path = require("path");
const dotenv = require("dotenv");
const { existsSync } = require("fs");
const JSON5 = require("json5");

/**
 * Generates a .env.example file from a .env file with user-friendly options.
 * @param {Object} [options] - Configuration options
 * @param {string} [options.envFilePath=".env"] - Path to source .env file
 * @param {string} [options.outputFilePath=".env.example"] - Path to output file
 * @param {string} [options.placeholder="<YOUR_VALUE_HERE>"] - Placeholder for values
 * @param {string[]} [options.preserveValues=[]] - Keys to keep original values
 * @param {string[]} [options.ignoreKeys=[]] - Keys to exclude from output
 * @param {boolean} [options.includeComments=true] - Preserve comments and empty lines
 * @param {string} [options.header] - Custom header
 * @param {boolean} [options.force=true] - Overwrite existing output file
 * @param {boolean} [options.silent=false] - Suppress console output
 * @param {boolean} [options.dryRun=false] - Preview output without writing
 * @param {string} [options.configFile=".genv-exrc"] - Path to config file
 * @returns {Promise<{ content: string, written: boolean, keys: string[], skippedKeys: string[] }>}
 */
async function generateEnvExample({
  envFilePath = ".env",
  outputFilePath = ".env.example",
  placeholder,
  preserveValues,
  ignoreKeys,
  includeComments,
  header,
  force = true,
  silent = false,
  dryRun = false,
  configFile = ".genv-exrc",
} = {}) {
  try {
    // Load config file if present
    let config = {};
    if (existsSync(configFile)) {
      try {
        config = JSON5.parse(await fs.readFile(configFile, "utf8"));
        !silent &&
          console.log(
            `Loaded configuration from '${configFile}':`,
            JSON.stringify(config, null, 2)
          );
      } catch (error) {
        !silent &&
          console.warn(
            `Warning: Failed to parse '${configFile}': ${error.message}`
          );
      }
    }

    // Define defaults
    const defaults = {
      envFilePath,
      outputFilePath,
      placeholder: config.placeholder || "<YOUR_VALUE_HERE>",
      preserveValues: config.preserveValues || [],
      ignoreKeys: config.ignoreKeys || [],
      includeComments:
        config.includeComments !== undefined ? config.includeComments : true,
      header: config.header
        ? config.header.replace(
            /\${new Date\(\)\.toISOString\(\)}/,
            new Date().toISOString()
          )
        : `# Generated by genv-ex\n# Auto-generated on ${new Date().toISOString()}\n`,
      force,
      silent,
      dryRun,
    };

    // Merge with passed options, prioritize config unless explicitly set
    const options = {
      envFilePath: envFilePath || defaults.envFilePath,
      outputFilePath: outputFilePath || defaults.outputFilePath,
      placeholder:
        typeof placeholder === "string" && placeholder.trim()
          ? placeholder
          : defaults.placeholder,
      preserveValues:
        Array.isArray(preserveValues) && preserveValues.length > 0
          ? preserveValues
          : defaults.preserveValues,
      ignoreKeys:
        Array.isArray(ignoreKeys) && ignoreKeys.length > 0
          ? ignoreKeys
          : defaults.ignoreKeys,
      includeComments:
        includeComments !== undefined
          ? includeComments
          : defaults.includeComments,
      header:
        typeof header === "string" && header.trim() ? header : defaults.header,
      force: force !== undefined ? force : defaults.force,
      silent: silent !== undefined ? silent : defaults.silent,
      dryRun: dryRun !== undefined ? dryRun : defaults.dryRun,
    };

    // Validate inputs
    if (
      typeof options.envFilePath !== "string" ||
      !options.envFilePath.trim()
    ) {
      throw new Error(
        'Invalid envFilePath: must be a non-empty string. Example: ".env"'
      );
    }
    if (
      typeof options.outputFilePath !== "string" ||
      !options.outputFilePath.trim()
    ) {
      throw new Error(
        'Invalid outputFilePath: must be a non-empty string. Example: ".env.example"'
      );
    }
    if (
      typeof options.placeholder !== "string" ||
      !options.placeholder.trim()
    ) {
      throw new Error(
        'Invalid placeholder: must be a non-empty string. Example: "<YOUR_VALUE_HERE>"'
      );
    }

    const envPath = path.resolve(process.cwd(), options.envFilePath);
    const outputPath = path.resolve(process.cwd(), options.outputFilePath);

    try {
      await fs.access(envPath);
    } catch {
      !silent &&
        console.log(
          `No '${options.envFilePath}' found at '${envPath}'.\n` +
            `Tip: Create a '.env' file with key-value pairs like:\n` +
            `  API_KEY=your_key\n  DATABASE_URL=your_url`
        );
      throw new Error(`No '${options.envFilePath}' file found`);
    }

    const envContent = await fs.readFile(envPath, "utf8");
    const parsedEnv = dotenv.parse(envContent);

    const keys = [];
    const skippedKeys = [];

    let exampleContent = options.header;

    console.log(options.includeComments);
    if (options.includeComments) {
      const lines = envContent.split(/\r?\n|\r/);
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineWithNewline = i < lines.length - 1 ? line + "\n" : line;

        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("#")) {
          exampleContent += lineWithNewline;
          continue;
        }

        // Updated regex to capture spacing around equals sign
        const match = line.match(/^(\s*)([^=#\s]+)(\s*=\s*)([^#]*?)(\s*#.*)?$/);

        if (match) {
          const [, leadingWhitespace, key, separator, value, comment = ""] =
            match;

          if (options.ignoreKeys.includes(key)) {
            skippedKeys.push(key);
            continue;
          }

          const newValue = options.preserveValues.includes(key)
            ? value
            : options.placeholder;

          // Preserve original spacing around equals sign
          exampleContent += `${leadingWhitespace}${key}${separator}${newValue}${comment}\n`;
          keys.push(key);
        } else {
          exampleContent += lineWithNewline;
        }
      }
    } else {
      for (const [key] of Object.entries(parsedEnv)) {
        if (options.ignoreKeys.includes(key)) {
          skippedKeys.push(key);
          continue;
        }
        const value = options.preserveValues.includes(key)
          ? parsedEnv[key]
          : options.placeholder;
        exampleContent += `${key}=${value}\n`;
        keys.push(key);
      }
    }

    exampleContent = exampleContent.replace(/\n+$/, "\n");

    if (options.dryRun) {
      !silent &&
        console.log(
          `Dry run: Would generate '${options.outputFilePath}':\n${exampleContent}`
        );
      return { content: exampleContent, written: false, keys, skippedKeys };
    }

    if (!options.force && existsSync(outputPath)) {
      !silent &&
        console.log(
          `Output file '${outputPath}' exists and force=false, skipping write.`
        );
      return { content: exampleContent, written: false, keys, skippedKeys };
    }

    await fs.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.writeFile(outputPath, exampleContent, "utf8");
    !silent &&
      console.log(
        `Successfully created '${options.outputFilePath}' with ${keys.length} keys`
      );

    return { content: exampleContent, written: true, keys, skippedKeys };
  } catch (error) {
    !silent && console.error(`Error: ${error.message}`);
    throw error;
  }
}

module.exports = generateEnvExample;
