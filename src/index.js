const fs = require("fs").promises;
const path = require("path");
const dotenv = require("dotenv");
const { createReadStream, existsSync } = require("fs");
const JSON5 = require("json5");

async function generateEnvExample({
  envFilePath = ".env",
  outputFilePath = ".env.example",
  placeholder = "<YOUR_VALUE_HERE>",
  preserveValues = [],
  ignoreKeys = [],
  includeComments = true,
  header = `# Generated by genv-ex\n# Auto-generated on ${new Date().toISOString()}\n`,
  force = true,
  silent = false,
  dryRun = false,
  configFile = ".genv-exrc",
} = {}) {
  try {
    // Load config file if present
    let config = {};
    if (existsSync(configFile)) {
      try {
        config = JSON5.parse(await fs.readFile(configFile, "utf8"));
        !silent && console.log(`Loaded configuration from '${configFile}'`);
      } catch (error) {
        !silent &&
          console.warn(
            `Warning: Failed to parse '${configFile}': ${error.message}`
          );
      }
    }

    // Merge config with options
    const options = {
      envFilePath,
      outputFilePath,
      placeholder,
      preserveValues,
      ignoreKeys,
      includeComments,
      header:
        header ||
        config.header ||
        `# Generated by genv-ex\n# Auto-generated on ${new Date().toISOString()}\n`,
      force,
      silent,
      dryRun,
    };

    // Validate inputs
    if (
      typeof options.envFilePath !== "string" ||
      !options.envFilePath.trim()
    ) {
      throw new Error(
        'Invalid envFilePath: must be a non-empty string. Example: ".env"'
      );
    }
    if (
      typeof options.outputFilePath !== "string" ||
      !options.outputFilePath.trim()
    ) {
      throw new Error(
        'Invalid outputFilePath: must be a non-empty string. Example: ".env.example"'
      );
    }
    if (
      typeof options.placeholder !== "string" ||
      !options.placeholder.trim()
    ) {
      throw new Error(
        'Invalid placeholder: must be a non-empty string. Example: "<YOUR_VALUE_HERE>"'
      );
    }

    // Resolve paths
    const envPath = path.resolve(process.cwd(), options.envFilePath);
    const outputPath = path.resolve(process.cwd(), options.outputFilePath);

    // Check if source file exists
    try {
      await fs.access(envPath);
    } catch {
      !silent &&
        console.log(
          `No '${options.envFilePath}' found at '${envPath}'.\n` +
            `Tip: Create a '.env' file with key-value pairs like:\n` +
            `  API_KEY=your_key\n  DATABASE_URL=your_url`
        );
      throw new Error(`No '${options.envFilePath}' file found`);
    }

    // Read and parse .env file
    const envContent = await fs.readFile(envPath, "utf8");
    const parsedEnv = dotenv.parse(envContent);
    const keys = [];
    const skippedKeys = [];

    // Check for empty .env
    if (Object.keys(parsedEnv).length === 0 && !options.includeComments) {
      !silent &&
        console.log(
          `'${options.envFilePath}' contains no valid key-value pairs.\n` +
            `Tip: Add entries like 'API_KEY=xyz123' to generate '${options.outputFilePath}'.`
        );
      return { content: "", written: false, keys, skippedKeys };
    }

    // Generate content
    let exampleContent = options.header;

    if (options.includeComments) {
      const lines = [];
      let currentLine = "";
      const stream = createReadStream(envPath, { encoding: "utf8" });

      for await (const chunk of stream) {
        currentLine += chunk;
        const lineArray = currentLine.split("\n");
        currentLine = lineArray.pop() || "";
        lines.push(...lineArray);
      }
      if (currentLine) lines.push(currentLine);

      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine) {
          exampleContent += "\n";
          continue;
        }
        if (trimmedLine.startsWith("#")) {
          exampleContent += `${line}\n`;
          continue;
        }
        const match = trimmedLine.match(/^([^=]+)=(.*)$/);
        if (match) {
          const key = match[1].trim();
          if (options.ignoreKeys.includes(key)) {
            skippedKeys.push(key);
            continue;
          }
          const value = options.preserveValues.includes(key)
            ? parsedEnv[key]
            : options.placeholder;
          exampleContent += `${key}=${value}\n`;
          keys.push(key);
        } else if (trimmedLine.includes("=")) {
          !silent &&
            console.warn(
              `Warning: Skipping malformed line in '${options.envFilePath}': "${line}"`
            );
        }
      }
    } else {
      for (const [key] of Object.entries(parsedEnv)) {
        if (options.ignoreKeys.includes(key)) {
          skippedKeys.push(key);
          continue;
        }
        const value = options.preserveValues.includes(key)
          ? parsedEnv[key]
          : options.placeholder;
        exampleContent += `${key}=${value}\n`;
        keys.push(key);
      }
    }

    // Check for no content
    if (exampleContent === options.header && !options.includeComments) {
      !silent &&
        console.log(
          `No keys included after filtering '${options.envFilePath}'.\n` +
            `Tip: Check 'ignoreKeys' or add valid entries to '${options.envFilePath}'.`
        );
      return { content: exampleContent, written: false, keys, skippedKeys };
    }

    // Dry-run mode
    if (options.dryRun) {
      !silent &&
        console.log(
          `Dry run: Would generate '${options.outputFilePath}':\n${exampleContent}`
        );
      return { content: exampleContent, written: false, keys, skippedKeys };
    }

    // Ensure output directory exists
    try {
      await fs.mkdir(path.dirname(outputPath), { recursive: true });
    } catch (error) {
      !silent &&
        console.error(
          `Cannot create directory for '${options.outputFilePath}'.\n` +
            `Tip: Check write permissions or specify a different path.`
        );
      throw error;
    }

    // Write the output file
    await fs.writeFile(outputPath, exampleContent, "utf8");
    !silent &&
      console.log(
        `Successfully created '${options.outputFilePath}' with ${keys.length} keys`
      );

    return { content: exampleContent, written: true, keys, skippedKeys };
  } catch (error) {
    const errorMessage =
      error.code === "ENOENT"
        ? `File system error: ${error.message}`
        : `Error: ${error.message}`;
    !silent && console.error(errorMessage);
    throw new Error(errorMessage);
  }
}

module.exports = generateEnvExample;
